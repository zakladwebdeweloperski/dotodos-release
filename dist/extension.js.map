{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://dotodos/./extension.js","webpack://dotodos/external commonjs \"vscode\"","webpack://dotodos/webpack/bootstrap","webpack://dotodos/webpack/startup"],"sourcesContent":["// The module 'vscode' contains the VS Code extensibility API\r\n// Import the module and reference it with the alias vscode in your code below\r\nconst vscode = require('vscode');\r\n\r\n/* ----------------------------------------------------------- */\r\n\r\nconst EXTENSION_NAME = 'dotodos';\r\nconst LANG_ID = 'dotodos';\r\n\r\n/**\r\n * Icons made out of characters\r\n */\r\nconst charcons = {\r\n\ttask: {\r\n\t\tdone: '☑',\r\n\t\ttodo: '☐'\r\n\t},\r\n};\r\n\r\nfunction getDotodoEditorOrErrorMessage() {\r\n\tconst activeEditor = vscode.window.activeTextEditor;\r\n\r\n\tif (!activeEditor || activeEditor.document.languageId !== LANG_ID) {\r\n\t\tvscode.window.showErrorMessage(`Please open a .${LANG_ID} file first`);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn activeEditor;\r\n}\r\n\r\n/* ----------------------------------------------------------- */\r\n\r\nfunction registerDecorations(context) {\r\n    // Cache for task content lines to avoid recalculating\r\n    let taskContentCache = new Map(); // key: documentUri_lineNumber, value: array of content line numbers\r\n    let documentVersion = -1;\r\n\r\n    // decoration for todo checkbox only\r\n    const todoDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editor.foreground')\r\n    });\r\n\r\n    // decoration for done checkbox and text (with strikethrough)\r\n    const doneDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editorLineNumber.foreground'),\r\n        textDecoration: 'line-through'\r\n    });\r\n\r\n    // decoration for timestamp on done tasks\r\n    const timestampDecoration = vscode.window.createTextEditorDecorationType({\r\n        after: {\r\n            color: new vscode.ThemeColor('editorHint.foreground'),\r\n            fontStyle: 'italic',\r\n            margin: '0 0 0 0.5em'\r\n        }\r\n    });\r\n\r\n    // decoration for sections (bold and themed color)\r\n    const sectionDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editorInfo.foreground'),\r\n        fontWeight: 'bold'\r\n    });\r\n\r\n    // decoration for section counters (displayed after section text)\r\n    const counterDecoration = vscode.window.createTextEditorDecorationType({\r\n        after: {\r\n            color: new vscode.ThemeColor('editorHint.foreground'),\r\n            fontStyle: 'normal',\r\n            fontWeight: 'normal'\r\n        }\r\n    });\r\n\r\n    // keep disposables so they get cleaned up\r\n    context.subscriptions.push(todoDecoration, doneDecoration, sectionDecoration, counterDecoration, timestampDecoration);\r\n\r\n    // Clear cache when document version changes\r\n    function clearCacheIfNeeded(doc) {\r\n        if (doc.version !== documentVersion) {\r\n            taskContentCache.clear();\r\n            documentVersion = doc.version;\r\n        }\r\n    }\r\n\r\n    function updateDecorations(editor) {\r\n        editor = editor || vscode.window.activeTextEditor;\r\n\r\n        if (!editor || editor.document.languageId !== LANG_ID) {\r\n            return;\r\n        }\r\n\r\n        clearCacheIfNeeded(editor.document);\r\n\r\n        const todoRanges = [];\r\n        const doneRanges = [];\r\n        const sectionRanges = [];\r\n        const counterRanges = [];\r\n        const timestampRanges = [];\r\n\r\n        for (let i = 0; i < editor.document.lineCount; i++) {\r\n            const line = editor.document.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n\r\n            if (trimmed.startsWith(charcons.task.todo)) {\r\n                // Only decorate the checkbox character, not the entire line\r\n                const checkboxStart = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex);\r\n                const checkboxEnd = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex + 1);\r\n                todoRanges.push(new vscode.Range(checkboxStart, checkboxEnd));\r\n            } else if (trimmed.startsWith(charcons.task.done)) {\r\n                // For done tasks, apply strikethrough only to non-whitespace runs\r\n                // Skip the checkbox character and the timestamp at the end\r\n                const checkboxEnd = line.firstNonWhitespaceCharacterIndex + charcons.task.done.length;\r\n                const timestampMatch = line.text.match(/ @\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\r\n                const textEnd = timestampMatch ? timestampMatch.index : line.text.length;\r\n                getNonWhitespaceRanges(line, i, doneRanges, checkboxEnd, textEnd);\r\n\r\n                // Also apply strikethrough to task content lines\r\n                const contentLines = getTaskContentLines(editor.document, i);\r\n                for (const contentLineNum of contentLines) {\r\n                    const contentLine = editor.document.lineAt(contentLineNum);\r\n                    if (contentLine.text.trim() !== '') {\r\n                        getNonWhitespaceRanges(contentLine, contentLineNum, doneRanges);\r\n                    }\r\n                }\r\n            } else if (isSectionLine(line.text)) {\r\n                // Section header - detect sections with or without counters\r\n                const sectionName = extractSectionName(trimmed);\r\n                const start = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex);\r\n                const end = new vscode.Position(i, line.text.length);\r\n                sectionRanges.push(new vscode.Range(start, end));\r\n\r\n                // Add counter decoration\r\n                const { doneCount, allCount } = countTasksInSection(editor.document, i);\r\n                let counterText;\r\n                \r\n                if (sectionName === 'Archived') {\r\n                    counterText = ` (${allCount})`;\r\n                } else {\r\n                    counterText = ` (${doneCount}/${allCount})`;\r\n                }\r\n\r\n                counterRanges.push({\r\n                    range: new vscode.Range(i, line.text.length, i, line.text.length),\r\n                    renderOptions: { after: { contentText: counterText } }\r\n                });\r\n            }\r\n        }\r\n\r\n        editor.setDecorations(todoDecoration, todoRanges);\r\n        editor.setDecorations(doneDecoration, doneRanges);\r\n        editor.setDecorations(sectionDecoration, sectionRanges);\r\n        editor.setDecorations(counterDecoration, counterRanges);\r\n        editor.setDecorations(timestampDecoration, timestampRanges);\r\n    }\r\n\r\n    // Helper functions for section detection and counting\r\n    function isSectionLine(lineText) {\r\n        const trimmed = lineText.trim();\r\n        if (!trimmed) return false;\r\n        // Sections must start at column 0 (no indentation)\r\n        if (lineText[0] !== trimmed[0]) return false;\r\n        if (isTaskLine(trimmed)) return false;\r\n        return trimmed.endsWith(':') || (trimmed.includes(':') && trimmed.includes('(') && trimmed.endsWith(')'));\r\n    }\r\n\r\n    function extractSectionName(trimmed) {\r\n        if (trimmed.includes(': (')) {\r\n            return trimmed.substring(0, trimmed.indexOf(': ('));\r\n        }\r\n        return trimmed.slice(0, -1); // remove :\r\n    }\r\n\r\n    function isTaskLine(trimmed) {\r\n        return trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done);\r\n    }\r\n\r\n    /**\r\n     * Get the content lines that belong to a task.\r\n     * Content is any text between the task and the next task/section.\r\n     * Returns array of line numbers that are content for the given task line.\r\n     * Uses caching to avoid recalculating for the same task.\r\n     */\r\n    function getTaskContentLines(doc, taskLineNum) {\r\n        const cacheKey = `${doc.uri.toString()}_${taskLineNum}`;\r\n        \r\n        // Check cache first\r\n        if (taskContentCache.has(cacheKey)) {\r\n            return taskContentCache.get(cacheKey);\r\n        }\r\n\r\n        const contentLines = [];\r\n        const taskLine = doc.lineAt(taskLineNum);\r\n        const taskIndent = taskLine.text.substring(0, taskLine.firstNonWhitespaceCharacterIndex).length;\r\n\r\n        // Look at lines below the task\r\n        for (let i = taskLineNum + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            const lineIndent = line.text.substring(0, line.firstNonWhitespaceCharacterIndex).length;\r\n\r\n            // Empty lines are part of content\r\n            if (trimmed === '') {\r\n                contentLines.push(i);\r\n                continue;\r\n            }\r\n\r\n            // If we hit another task at same or less indentation, stop\r\n            if (isTaskLine(trimmed) && lineIndent <= taskIndent) {\r\n                break;\r\n            }\r\n\r\n            // If we hit a section, stop\r\n            if (isSectionLine(line.text)) {\r\n                break;\r\n            }\r\n\r\n            // If we hit a task at deeper indentation, it's a subtask, not content - stop\r\n            if (isTaskLine(trimmed) && lineIndent > taskIndent) {\r\n                break;\r\n            }\r\n\r\n            // Otherwise, this line is content\r\n            contentLines.push(i);\r\n        }\r\n\r\n        // Cache the result\r\n        taskContentCache.set(cacheKey, contentLines);\r\n        return contentLines;\r\n    }\r\n\r\n    /**\r\n     * Pushes ranges covering only non-whitespace character runs on a line.\r\n     * This ensures strikethrough decoration doesn't bleed through tabs/spaces.\r\n     * @param {vscode.TextLine} line - The text line to process\r\n     * @param {number} lineNum - The line number\r\n     * @param {vscode.Range[]} ranges - Array to push ranges into\r\n     * @param {number} [startCol] - Optional start column (defaults to first non-whitespace)\r\n     * @param {number} [endCol] - Optional end column (defaults to line length)\r\n     */\r\n    function getNonWhitespaceRanges(line, lineNum, ranges, startCol, endCol) {\r\n        const text = line.text;\r\n        let i = startCol !== undefined ? startCol : line.firstNonWhitespaceCharacterIndex;\r\n        const end = endCol !== undefined ? endCol : text.length;\r\n        while (i < end) {\r\n            // Skip whitespace\r\n            if (text[i] === ' ' || text[i] === '\\t') {\r\n                i++;\r\n                continue;\r\n            }\r\n            // Start of a non-whitespace run\r\n            const start = i;\r\n            while (i < end && text[i] !== ' ' && text[i] !== '\\t') {\r\n                i++;\r\n            }\r\n            ranges.push(new vscode.Range(lineNum, start, lineNum, i));\r\n        }\r\n    }\r\n\r\n    function countTasksInSection(doc, sectionLine) {\r\n        let doneCount = 0;\r\n        let todoCount = 0;\r\n        \r\n        // Find next section or end of document\r\n        let nextSectionLine = doc.lineCount;\r\n        for (let i = sectionLine + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            if (isSectionLine(line.text)) {\r\n                nextSectionLine = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Count tasks between this section and next section\r\n        for (let i = sectionLine + 1; i < nextSectionLine; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            if (trimmed.startsWith(charcons.task.done)) {\r\n                doneCount++;\r\n            } else if (trimmed.startsWith(charcons.task.todo)) {\r\n                todoCount++;\r\n            }\r\n        }\r\n\r\n        return { doneCount, todoCount, allCount: doneCount + todoCount };\r\n    }\r\n\r\n    // update when active editor changes\r\n    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {\r\n        updateDecorations(editor);\r\n    }));\r\n\r\n    // update when document text changes\r\n    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(event => {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor && event.document === editor.document && editor.document.languageId === LANG_ID) {\r\n            updateDecorations(editor);\r\n        }\r\n    }));\r\n\r\n    // initial run\r\n    updateDecorations();\r\n}\r\n\r\n/**\r\n * This method is called when your extension is activated.\r\n * Your extension is activated the very first time the command is executed.\r\n * @param {vscode.ExtensionContext} context\r\n */\r\nfunction activate(context) {\r\n\tconst subscriptions = {\r\n\t\tmarkAsTask: vscode.commands.registerCommand(`${EXTENSION_NAME}.markAsTask`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst doc = editor.document;\r\n\t\t\t\tconst lineNum = editor.selection.active.line;\r\n\t\t\t\tconst line = doc.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst trimmed = text.trim();\r\n\t\t\t\tconst insertCol = line.firstNonWhitespaceCharacterIndex;\r\n\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\tconst start = new vscode.Position(lineNum, insertCol);\r\n\t\t\t\t\tconst end = new vscode.Position(lineNum, insertCol + charcons.task.todo.length + 1);\r\n\t\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\t\teditBuilder.delete(new vscode.Range(start, end));\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Insert after indentation so we keep the original indentation\r\n\t\t\t\tconst insertPos = new vscode.Position(lineNum, line.firstNonWhitespaceCharacterIndex);\r\n\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.insert(insertPos, `${charcons.task.todo} `);\r\n\t\t\t\t});\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to mark as task: ${error.message}`);\r\n\t\t\t\tconsole.error('Mark as task error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\r\n\t\ttoggleTaskState: vscode.commands.registerCommand(`${EXTENSION_NAME}.toggleTaskState`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst doc = editor.document;\r\n\t\t\t\tconst lineNum = editor.selection.active.line;\r\n\t\t\t\tconst line = doc.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst leadingWhitespace = text.substring(0, line.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo)) {\r\n\t\t\t\t// Mark current task as done and add timestamp\r\n\t\t\t\tconst now = new Date();\r\n\t\t\t\tconst timestamp = ` @${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;\r\n\t\t\t\tconst taskContent = trimmed.slice(charcons.task.todo.length + 1);\r\n\t\t\t\tconst newTaskText = `${leadingWhitespace}${charcons.task.done} ${taskContent}${timestamp}`;\r\n\t\t\t\t\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.replace(line.range, newTaskText);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find and mark all subtasks as done\r\n\t\t\t\t\tconst currentIndentLevel = leadingWhitespace.length;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Look at all lines below the current task\r\n\t\t\t\t\tfor (let i = lineNum + 1; i < doc.lineCount; i++) {\r\n\t\t\t\t\t\tconst subtaskLine = doc.lineAt(i);\r\n\t\t\t\t\t\tconst subtaskText = subtaskLine.text;\r\n\t\t\t\t\t\tconst subtaskTrimmed = subtaskText.trim();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we reach an empty line or a line with same/less indentation that's not a task\r\n\t\t\t\t\t\tif (subtaskTrimmed === '') {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst subtaskIndentLevel = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex).length;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we encounter a line with same or less indentation\r\n\t\t\t\t\t\tif (subtaskIndentLevel <= currentIndentLevel) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// If it's a subtask (more indented and is a task), mark it as done with timestamp\r\n\t\t\t\t\t\tif (subtaskTrimmed.startsWith(charcons.task.todo)) {\r\n\t\t\t\t\t\t\tconst subtaskLeadingWhitespace = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\t\t\t\tconst subtaskContent = subtaskTrimmed.slice(charcons.task.todo.length + 1);\r\n\t\t\t\t\t\t\tconst newSubtaskText = `${subtaskLeadingWhitespace}${charcons.task.done} ${subtaskContent}${timestamp}`;\r\n\t\t\t\t\t\t\teditBuilder.replace(subtaskLine.range, newSubtaskText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else if (trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t// Mark current task as todo (undone) and remove timestamp\r\n\t\t\t\tlet taskContent = trimmed.slice(charcons.task.done.length + 1);\r\n\t\t\t\t// Remove timestamp if present (format: @YYYY-MM-DD HH:mm:ss)\r\n\t\t\t\ttaskContent = taskContent.replace(/ @\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/, '');\r\n\t\t\t\tconst newTaskText = `${leadingWhitespace}${charcons.task.todo} ${taskContent}`;\r\n\t\t\t\t\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.replace(line.range, newTaskText);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find and mark all subtasks as undone (todo)\r\n\t\t\t\t\tconst currentIndentLevel = leadingWhitespace.length;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Look at all lines below the current task\r\n\t\t\t\t\tfor (let i = lineNum + 1; i < doc.lineCount; i++) {\r\n\t\t\t\t\t\tconst subtaskLine = doc.lineAt(i);\r\n\t\t\t\t\t\tconst subtaskText = subtaskLine.text;\r\n\t\t\t\t\t\tconst subtaskTrimmed = subtaskText.trim();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we reach an empty line or a line with same/less indentation that's not a task\r\n\t\t\t\t\t\tif (subtaskTrimmed === '') {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst subtaskIndentLevel = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex).length;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we encounter a line with same or less indentation\r\n\t\t\t\t\t\tif (subtaskIndentLevel <= currentIndentLevel) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// If it's a subtask (more indented and is a task), mark it as undone and remove timestamp\r\n\t\t\t\t\t\tif (subtaskTrimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t\t\tconst subtaskLeadingWhitespace = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\t\t\t\tlet subtaskContent = subtaskTrimmed.slice(charcons.task.done.length + 1);\r\n\t\t\t\t\t\t\t// Remove timestamp if present\r\n\t\t\t\t\t\t\tsubtaskContent = subtaskContent.replace(/ @\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/, '');\r\n\t\t\t\t\t\t\tconst newSubtaskText = `${subtaskLeadingWhitespace}${charcons.task.todo} ${subtaskContent}`;\r\n\t\t\t\t\t\t\teditBuilder.replace(subtaskLine.range, newSubtaskText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to toggle task state: ${error.message}`);\r\n\t\t\t\tconsole.error('Toggle task state error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\r\n\t\tarchiveDone: vscode.commands.registerCommand(`${EXTENSION_NAME}.archiveDone`, archiveDone),\r\n\r\n\t\tindentTask: vscode.commands.registerCommand(`${EXTENSION_NAME}.indentTask`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\t' });\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst selection = editor.selection;\r\n\t\t\tconst startLine = selection.start.line;\r\n\t\t\tconst endLine = selection.end.line;\r\n\r\n\t\t\t// Check if we have a multi-line selection\r\n\t\t\tif (startLine !== endLine) {\r\n\t\t\t\t// Multi-line selection: indent all task lines in the selection\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\tfor (let lineNum = startLine; lineNum <= endLine; lineNum++) {\r\n\t\t\t\t\t\tconst line = editor.document.lineAt(lineNum);\r\n\t\t\t\t\t\tconst text = line.text;\r\n\t\t\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\t\t\t// Only indent lines that are tasks\r\n\t\t\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t\t\teditBuilder.insert(new vscode.Position(lineNum, 0), '\\t');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}).then(() => {\r\n\t\t\t\t\t// Maintain the selection but adjust for the added tabs\r\n\t\t\t\t\tconst newStart = new vscode.Position(startLine, selection.start.character + 1);\r\n\t\t\t\t\tconst newEnd = new vscode.Position(endLine, selection.end.character + 1);\r\n\t\t\t\t\teditor.selection = new vscode.Selection(newStart, newEnd);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\t// Single line: existing behavior\r\n\t\t\t\tconst position = editor.selection.active;\r\n\t\t\t\tconst lineNum = position.line;\r\n\t\t\t\tconst line = editor.document.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\t// Check if current line is a task\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t// Add tab at the beginning of the line\r\n\t\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\t\teditBuilder.insert(new vscode.Position(lineNum, 0), '\\t');\r\n\t\t\t\t\t}).then(() => {\r\n\t\t\t\t\t\t// Maintain cursor position relative to the line content\r\n\t\t\t\t\t\tconst newPosition = new vscode.Position(lineNum, position.character + 1);\r\n\t\t\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Default tab behavior for non-task lines\r\n\t\t\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\t' });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to indent task: ${error.message}`);\r\n\t\t\t\tconsole.error('Indent task error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\t};\r\n\r\n\tregisterDecorations(context);\r\n\r\n\t// Track newly created empty tasks for double-enter cancellation and ESC cancellation\r\n\tlet lastCreatedTaskInfo = null;\r\n\r\n\tfunction setNewEmptyTaskContext(value) {\r\n\t\tvscode.commands.executeCommand('setContext', 'dotodos.newEmptyTask', value);\r\n\t}\r\n\r\n\t// Auto-create task on Enter key\r\n\tconst enterDisposable = vscode.commands.registerCommand(`${EXTENSION_NAME}.onEnter`, () => {\r\n\t\tconst editor = vscode.window.activeTextEditor;\r\n\t\tif (!editor || editor.document.languageId !== LANG_ID) {\r\n\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t}\r\n\r\n\t\tconst position = editor.selection.active;\r\n\t\tconst currentLine = editor.document.lineAt(position.line);\r\n\t\tconst currentText = currentLine.text;\r\n\t\tconst trimmed = currentText.trim();\r\n\r\n\t\t// Check for double-enter on empty task (cancel task creation)\r\n\t\tif (lastCreatedTaskInfo && \r\n\t\t\tlastCreatedTaskInfo.line === position.line && \r\n\t\t\tlastCreatedTaskInfo.text === currentText &&\r\n\t\t\ttrimmed === charcons.task.todo) {\r\n\t\t\t// Remove the task checkbox and space, keep only indentation\r\n\t\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.replace(currentLine.range, indentation);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Insert newline after removing checkbox\r\n\t\t\t\tvscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t\t});\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\tsetNewEmptyTaskContext(false);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Check if current line is a task AND cursor is at the end of the line\r\n\t\tif ((trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) && \r\n\t\t\tposition.character === currentText.length) {\r\n\t\t\t// Get indentation of current line\r\n\t\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\tconst newTaskLine = `${indentation}${charcons.task.todo} `;\r\n\t\t\t\r\n\t\t\t// Insert new line with new task at the end of current line\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.insert(new vscode.Position(position.line, currentText.length), '\\n' + newTaskLine);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Position cursor at end of new task line\r\n\t\t\t\tconst newPosition = new vscode.Position(position.line + 1, newTaskLine.length);\r\n\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t\t\r\n\t\t\t\t// Track this new task for potential double-enter/backspace/esc cancellation\r\n\t\t\t\tlastCreatedTaskInfo = {\r\n\t\t\t\t\tline: position.line + 1,\r\n\t\t\t\t\ttext: newTaskLine\r\n\t\t\t\t};\r\n\t\t\t\tsetNewEmptyTaskContext(true);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// Default behavior for non-task lines or when cursor is not at end\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\tsetNewEmptyTaskContext(false);\r\n\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t}\r\n\t});\r\n\r\n\t// Handle BACKSPACE key to cancel task creation\r\n\tconst backspaceDisposable = vscode.commands.registerCommand(`${EXTENSION_NAME}.onBackspace`, () => {\r\n\t\tconst editor = vscode.window.activeTextEditor;\r\n\t\tif (!editor || editor.document.languageId !== LANG_ID) {\r\n\t\t\treturn vscode.commands.executeCommand('deleteLeft');\r\n\t\t}\r\n\r\n\t\tconst position = editor.selection.active;\r\n\t\tconst currentLine = editor.document.lineAt(position.line);\r\n\t\tconst currentText = currentLine.text;\r\n\t\tconst trimmed = currentText.trim();\r\n\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\r\n\t\t// Check if cursor is right after the space following the checkbox (at the end of \"☐ \")\r\n\t\tif (lastCreatedTaskInfo && \r\n\t\t\tlastCreatedTaskInfo.line === position.line && \r\n\t\t\ttrimmed === charcons.task.todo &&\r\n\t\t\tposition.character === indentation.length + charcons.task.todo.length + 1) {\r\n\t\t\t// Remove checkbox and space, keep indentation\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.replace(currentLine.range, indentation);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Move cursor to end of indentation\r\n\t\t\t\tconst newPosition = new vscode.Position(position.line, indentation.length);\r\n\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t});\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\tsetNewEmptyTaskContext(false);\r\n\t\t} else {\r\n\t\t\t// Default BACKSPACE behavior\r\n\t\t\treturn vscode.commands.executeCommand('deleteLeft');\r\n\t\t}\r\n\t});\r\n\r\n\t// Handle ESC key to cancel task creation (remove checkbox, keep indentation and cursor)\r\n\tconst escDisposable = vscode.commands.registerCommand(`${EXTENSION_NAME}.onEsc`, () => {\r\n\t\tconst editor = vscode.window.activeTextEditor;\r\n\t\tif (!editor || editor.document.languageId !== LANG_ID) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst position = editor.selection.active;\r\n\t\tconst currentLine = editor.document.lineAt(position.line);\r\n\t\tconst currentText = currentLine.text;\r\n\t\tconst trimmed = currentText.trim();\r\n\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\r\n\t\t// Only act if this is a tracked newly created empty task\r\n\t\tif (lastCreatedTaskInfo &&\r\n\t\t\tlastCreatedTaskInfo.line === position.line &&\r\n\t\t\ttrimmed === charcons.task.todo) {\r\n\t\t\t// Remove checkbox and space, keep indentation, keep cursor in place\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.replace(currentLine.range, indentation);\r\n\t\t\t}).then(() => {\r\n\t\t\t\tconst newPosition = new vscode.Position(position.line, indentation.length);\r\n\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t});\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\tsetNewEmptyTaskContext(false);\r\n\t\t}\r\n\t});\r\n\r\n\tcontext.subscriptions.push(enterDisposable, backspaceDisposable, escDisposable);\r\n\r\n\t// Without pushing to context.subscriptions, cleanup would not happen \r\n\t// automatically, which can cause issues especially if the extension \r\n\t// is enabled/disabled multiple times during a session.\r\n\tcontext.subscriptions.push(...Object.values(subscriptions));\r\n\t// context.subscriptions.push(commands.markAsTask);\r\n}\r\n\r\n// This method is called when your extension is deactivated\r\nfunction deactivate() {}\r\n\r\nfunction archiveDone() {\r\n    try {\r\n        const editor = getDotodoEditorOrErrorMessage();\r\n        if (!editor) return;\r\n\r\n        const doc = editor.document;\r\n    const allLines = [];\r\n    const doneTasksWithContent = [];\r\n    const linesToSkip = new Set();\r\n\r\n    // Helper function to check if line is a task\r\n    function isTaskLine(trimmed) {\r\n        return trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done);\r\n    }\r\n\r\n    // Helper function to check if line is a section\r\n    function isSectionLine(lineText) {\r\n        const trimmed = lineText.trim();\r\n        if (!trimmed) return false;\r\n        // Sections must start at column 0 (no indentation)\r\n        if (lineText[0] !== trimmed[0]) return false;\r\n        if (isTaskLine(trimmed)) return false;\r\n        return trimmed.endsWith(':') || (trimmed.includes(':') && trimmed.includes('(') && trimmed.endsWith(')'));\r\n    }\r\n\r\n    // Helper to get content lines for a task\r\n    function getTaskContentLines(taskLineNum) {\r\n        const contentLines = [];\r\n        const taskLine = doc.lineAt(taskLineNum);\r\n        const taskIndent = taskLine.text.substring(0, taskLine.firstNonWhitespaceCharacterIndex).length;\r\n\r\n        for (let i = taskLineNum + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            const lineIndent = line.text.substring(0, line.firstNonWhitespaceCharacterIndex).length;\r\n\r\n            if (trimmed === '') {\r\n                contentLines.push(i);\r\n                continue;\r\n            }\r\n\r\n            if (isTaskLine(trimmed) && lineIndent <= taskIndent) {\r\n                break;\r\n            }\r\n\r\n            if (isSectionLine(line.text)) {\r\n                break;\r\n            }\r\n\r\n            if (isTaskLine(trimmed) && lineIndent > taskIndent) {\r\n                break;\r\n            }\r\n\r\n            contentLines.push(i);\r\n        }\r\n\r\n        return contentLines;\r\n    }\r\n\r\n    // First pass: collect done tasks with their content\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n        if (linesToSkip.has(i)) continue;\r\n\r\n        const line = doc.lineAt(i);\r\n        const trimmed = line.text.trim();\r\n        \r\n        if (trimmed.startsWith(charcons.task.done)) {\r\n            // Add the task line\r\n            doneTasksWithContent.push(line.text);\r\n            linesToSkip.add(i);\r\n\r\n            // Get and add content lines\r\n            const contentLines = getTaskContentLines(i);\r\n            for (const contentLineNum of contentLines) {\r\n                doneTasksWithContent.push(doc.lineAt(contentLineNum).text);\r\n                linesToSkip.add(contentLineNum);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (doneTasksWithContent.length === 0) {\r\n        vscode.window.showInformationMessage('No done tasks to archive');\r\n        return;\r\n    }\r\n\r\n    // Second pass: collect remaining lines\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n        if (!linesToSkip.has(i)) {\r\n            allLines.push(doc.lineAt(i).text);\r\n        }\r\n    }\r\n\r\n    // Check if Archived exists\r\n    let hasArchived = false;\r\n    for (let line of allLines) {\r\n        if (line.trim().startsWith('Archived:')) {\r\n            hasArchived = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!hasArchived) {\r\n        allLines.push('', 'Archived:');\r\n    }\r\n\r\n    // Add done tasks with their content\r\n    allLines.push(...doneTasksWithContent);\r\n\r\n    // Replace entire document\r\n    const newText = allLines.join('\\n');\r\n    editor.edit(editBuilder => {\r\n        editBuilder.replace(new vscode.Range(0, 0, doc.lineCount, 0), newText);\r\n    });\r\n    } catch (error) {\r\n        vscode.window.showErrorMessage(`Failed to archive done tasks: ${error.message}`);\r\n        console.error('Archive done error:', error);\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n\tactivate,\r\n\tdeactivate\r\n}\r\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(12);\n"],"names":["vscode","EXTENSION_NAME","LANG_ID","charcons","getDotodoEditorOrErrorMessage","activeEditor","window","activeTextEditor","document","languageId","showErrorMessage","archiveDone","editor","doc","allLines","doneTasksWithContent","linesToSkip","Set","isTaskLine","trimmed","startsWith","isSectionLine","lineText","trim","endsWith","includes","getTaskContentLines","taskLineNum","contentLines","taskLine","lineAt","taskIndent","text","substring","firstNonWhitespaceCharacterIndex","length","i","lineCount","line","lineIndent","push","has","add","contentLineNum","showInformationMessage","hasArchived","newText","join","edit","editBuilder","replace","Range","error","message","console","module","exports","activate","context","subscriptions","markAsTask","commands","registerCommand","lineNum","selection","active","insertCol","start","Position","end","delete","insertPos","insert","toggleTaskState","leadingWhitespace","now","Date","timestamp","getFullYear","String","getMonth","padStart","getDate","getHours","getMinutes","getSeconds","taskContent","slice","newTaskText","range","currentIndentLevel","subtaskLine","subtaskText","subtaskTrimmed","subtaskLeadingWhitespace","subtaskContent","newSubtaskText","indentTask","executeCommand","startLine","endLine","then","newStart","character","newEnd","Selection","position","newPosition","taskContentCache","Map","documentVersion","todoDecoration","createTextEditorDecorationType","color","ThemeColor","doneDecoration","textDecoration","timestampDecoration","after","fontStyle","margin","sectionDecoration","fontWeight","counterDecoration","updateDecorations","version","clear","todoRanges","doneRanges","sectionRanges","counterRanges","checkboxStart","checkboxEnd","timestampMatch","match","getNonWhitespaceRanges","index","contentLine","sectionName","extractSectionName","doneCount","allCount","countTasksInSection","counterText","renderOptions","contentText","setDecorations","indexOf","cacheKey","uri","toString","get","set","ranges","startCol","endCol","undefined","sectionLine","todoCount","nextSectionLine","onDidChangeActiveTextEditor","workspace","onDidChangeTextDocument","event","registerDecorations","lastCreatedTaskInfo","setNewEmptyTaskContext","value","enterDisposable","currentLine","currentText","indentation","newTaskLine","backspaceDisposable","escDisposable","Object","values","deactivate","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"ignoreList":[],"sourceRoot":""}