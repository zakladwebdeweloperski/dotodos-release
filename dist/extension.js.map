{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://dotodos/./extension.js","webpack://dotodos/external commonjs \"vscode\"","webpack://dotodos/webpack/bootstrap","webpack://dotodos/webpack/startup"],"sourcesContent":["// The module 'vscode' contains the VS Code extensibility API\r\n// Import the module and reference it with the alias vscode in your code below\r\nconst vscode = require('vscode');\r\n\r\n/* ----------------------------------------------------------- */\r\n\r\nconst EXTENSION_NAME = 'dotodos';\r\nconst LANG_ID = 'dotodos';\r\n\r\n/**\r\n * Icons made out of characters\r\n */\r\nconst charcons = {\r\n\ttask: {\r\n\t\tdone: '☑',\r\n\t\ttodo: '☐'\r\n\t},\r\n};\r\n\r\nfunction getDotodoEditorOrErrorMessage() {\r\n\tconst activeEditor = vscode.window.activeTextEditor;\r\n\r\n\tif (!activeEditor || activeEditor.document.languageId !== LANG_ID) {\r\n\t\tvscode.window.showErrorMessage(`Please open a .${LANG_ID} file first`);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn activeEditor;\r\n}\r\n\r\n/* ----------------------------------------------------------- */\r\n\r\nfunction registerDecorations(context) {\r\n    // Cache for task content lines to avoid recalculating\r\n    let taskContentCache = new Map(); // key: documentUri_lineNumber, value: array of content line numbers\r\n    let documentVersion = -1;\r\n\r\n    // decoration for todo checkbox only\r\n    const todoDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editor.foreground')\r\n    });\r\n\r\n    // decoration for done checkbox and text (with strikethrough)\r\n    const doneDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editorLineNumber.foreground'),\r\n        textDecoration: 'line-through'\r\n    });\r\n\r\n    // decoration for timestamp on done tasks\r\n    const timestampDecoration = vscode.window.createTextEditorDecorationType({\r\n        after: {\r\n            color: new vscode.ThemeColor('editorHint.foreground'),\r\n            fontStyle: 'italic',\r\n            margin: '0 0 0 0.5em'\r\n        }\r\n    });\r\n\r\n    // decoration for sections (bold and themed color)\r\n    const sectionDecoration = vscode.window.createTextEditorDecorationType({\r\n        color: new vscode.ThemeColor('editorInfo.foreground'),\r\n        fontWeight: 'bold'\r\n    });\r\n\r\n    // decoration for section counters (displayed after section text)\r\n    const counterDecoration = vscode.window.createTextEditorDecorationType({\r\n        after: {\r\n            color: new vscode.ThemeColor('editorHint.foreground'),\r\n            fontStyle: 'normal',\r\n            fontWeight: 'normal'\r\n        }\r\n    });\r\n\r\n    // keep disposables so they get cleaned up\r\n    context.subscriptions.push(todoDecoration, doneDecoration, sectionDecoration, counterDecoration, timestampDecoration);\r\n\r\n    // Clear cache when document version changes\r\n    function clearCacheIfNeeded(doc) {\r\n        if (doc.version !== documentVersion) {\r\n            taskContentCache.clear();\r\n            documentVersion = doc.version;\r\n        }\r\n    }\r\n\r\n    function updateDecorations(editor) {\r\n        editor = editor || vscode.window.activeTextEditor;\r\n\r\n        if (!editor || editor.document.languageId !== LANG_ID) {\r\n            return;\r\n        }\r\n\r\n        clearCacheIfNeeded(editor.document);\r\n\r\n        const todoRanges = [];\r\n        const doneRanges = [];\r\n        const sectionRanges = [];\r\n        const counterRanges = [];\r\n        const timestampRanges = [];\r\n\r\n        for (let i = 0; i < editor.document.lineCount; i++) {\r\n            const line = editor.document.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n\r\n            if (trimmed.startsWith(charcons.task.todo)) {\r\n                // Only decorate the checkbox character, not the entire line\r\n                const checkboxStart = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex);\r\n                const checkboxEnd = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex + 1);\r\n                todoRanges.push(new vscode.Range(checkboxStart, checkboxEnd));\r\n            } else if (trimmed.startsWith(charcons.task.done)) {\r\n                // For done tasks, apply strikethrough only to non-whitespace runs\r\n                getNonWhitespaceRanges(line, i, doneRanges);\r\n\r\n                // Also apply strikethrough to task content lines\r\n                const contentLines = getTaskContentLines(editor.document, i);\r\n                for (const contentLineNum of contentLines) {\r\n                    const contentLine = editor.document.lineAt(contentLineNum);\r\n                    if (contentLine.text.trim() !== '') {\r\n                        getNonWhitespaceRanges(contentLine, contentLineNum, doneRanges);\r\n                    }\r\n                }\r\n            } else if (isSectionLine(trimmed)) {\r\n                // Section header - detect sections with or without counters\r\n                const sectionName = extractSectionName(trimmed);\r\n                const start = new vscode.Position(i, line.firstNonWhitespaceCharacterIndex);\r\n                const end = new vscode.Position(i, line.text.length);\r\n                sectionRanges.push(new vscode.Range(start, end));\r\n\r\n                // Add counter decoration\r\n                const { doneCount, allCount } = countTasksInSection(editor.document, i);\r\n                let counterText;\r\n                \r\n                if (sectionName === 'Archived') {\r\n                    counterText = ` (${allCount})`;\r\n                } else {\r\n                    counterText = ` (${doneCount}/${allCount})`;\r\n                }\r\n\r\n                counterRanges.push({\r\n                    range: new vscode.Range(i, line.text.length, i, line.text.length),\r\n                    renderOptions: { after: { contentText: counterText } }\r\n                });\r\n            }\r\n        }\r\n\r\n        editor.setDecorations(todoDecoration, todoRanges);\r\n        editor.setDecorations(doneDecoration, doneRanges);\r\n        editor.setDecorations(sectionDecoration, sectionRanges);\r\n        editor.setDecorations(counterDecoration, counterRanges);\r\n        editor.setDecorations(timestampDecoration, timestampRanges);\r\n    }\r\n\r\n    // Helper functions for section detection and counting\r\n    function isSectionLine(trimmed) {\r\n        return trimmed.endsWith(':') || (trimmed.includes(':') && trimmed.includes('(') && trimmed.endsWith(')'));\r\n    }\r\n\r\n    function extractSectionName(trimmed) {\r\n        if (trimmed.includes(': (')) {\r\n            return trimmed.substring(0, trimmed.indexOf(': ('));\r\n        }\r\n        return trimmed.slice(0, -1); // remove :\r\n    }\r\n\r\n    function isTaskLine(trimmed) {\r\n        return trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done);\r\n    }\r\n\r\n    /**\r\n     * Get the content lines that belong to a task.\r\n     * Content is any text between the task and the next task/section.\r\n     * Returns array of line numbers that are content for the given task line.\r\n     * Uses caching to avoid recalculating for the same task.\r\n     */\r\n    function getTaskContentLines(doc, taskLineNum) {\r\n        const cacheKey = `${doc.uri.toString()}_${taskLineNum}`;\r\n        \r\n        // Check cache first\r\n        if (taskContentCache.has(cacheKey)) {\r\n            return taskContentCache.get(cacheKey);\r\n        }\r\n\r\n        const contentLines = [];\r\n        const taskLine = doc.lineAt(taskLineNum);\r\n        const taskIndent = taskLine.text.substring(0, taskLine.firstNonWhitespaceCharacterIndex).length;\r\n\r\n        // Look at lines below the task\r\n        for (let i = taskLineNum + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            const lineIndent = line.text.substring(0, line.firstNonWhitespaceCharacterIndex).length;\r\n\r\n            // Empty lines are part of content\r\n            if (trimmed === '') {\r\n                contentLines.push(i);\r\n                continue;\r\n            }\r\n\r\n            // If we hit another task at same or less indentation, stop\r\n            if (isTaskLine(trimmed) && lineIndent <= taskIndent) {\r\n                break;\r\n            }\r\n\r\n            // If we hit a section, stop\r\n            if (isSectionLine(trimmed)) {\r\n                break;\r\n            }\r\n\r\n            // If we hit a task at deeper indentation, it's a subtask, not content - stop\r\n            if (isTaskLine(trimmed) && lineIndent > taskIndent) {\r\n                break;\r\n            }\r\n\r\n            // Otherwise, this line is content\r\n            contentLines.push(i);\r\n        }\r\n\r\n        // Cache the result\r\n        taskContentCache.set(cacheKey, contentLines);\r\n        return contentLines;\r\n    }\r\n\r\n    /**\r\n     * Pushes ranges covering only non-whitespace character runs on a line.\r\n     * This ensures strikethrough decoration doesn't bleed through tabs/spaces.\r\n     */\r\n    function getNonWhitespaceRanges(line, lineNum, ranges) {\r\n        const text = line.text;\r\n        let i = line.firstNonWhitespaceCharacterIndex;\r\n        while (i < text.length) {\r\n            // Skip whitespace\r\n            if (text[i] === ' ' || text[i] === '\\t') {\r\n                i++;\r\n                continue;\r\n            }\r\n            // Start of a non-whitespace run\r\n            const start = i;\r\n            while (i < text.length && text[i] !== ' ' && text[i] !== '\\t') {\r\n                i++;\r\n            }\r\n            ranges.push(new vscode.Range(lineNum, start, lineNum, i));\r\n        }\r\n    }\r\n\r\n    function countTasksInSection(doc, sectionLine) {\r\n        let doneCount = 0;\r\n        let todoCount = 0;\r\n        \r\n        // Find next section or end of document\r\n        let nextSectionLine = doc.lineCount;\r\n        for (let i = sectionLine + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            if (isSectionLine(line.text.trim())) {\r\n                nextSectionLine = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Count tasks between this section and next section\r\n        for (let i = sectionLine + 1; i < nextSectionLine; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            if (trimmed.startsWith(charcons.task.done)) {\r\n                doneCount++;\r\n            } else if (trimmed.startsWith(charcons.task.todo)) {\r\n                todoCount++;\r\n            }\r\n        }\r\n\r\n        return { doneCount, todoCount, allCount: doneCount + todoCount };\r\n    }\r\n\r\n    // update when active editor changes\r\n    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {\r\n        updateDecorations(editor);\r\n    }));\r\n\r\n    // update when document text changes\r\n    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(event => {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor && event.document === editor.document && editor.document.languageId === LANG_ID) {\r\n            updateDecorations(editor);\r\n        }\r\n    }));\r\n\r\n    // initial run\r\n    updateDecorations();\r\n}\r\n\r\n/**\r\n * This method is called when your extension is activated.\r\n * Your extension is activated the very first time the command is executed.\r\n * @param {vscode.ExtensionContext} context\r\n */\r\nfunction activate(context) {\r\n\tconst subscriptions = {\r\n\t\tmarkAsTask: vscode.commands.registerCommand(`${EXTENSION_NAME}.markAsTask`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst doc = editor.document;\r\n\t\t\t\tconst lineNum = editor.selection.active.line;\r\n\t\t\t\tconst line = doc.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst trimmed = text.trim();\r\n\t\t\t\tconst insertCol = line.firstNonWhitespaceCharacterIndex;\r\n\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\tconst start = new vscode.Position(lineNum, insertCol);\r\n\t\t\t\t\tconst end = new vscode.Position(lineNum, insertCol + charcons.task.todo.length + 1);\r\n\t\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\t\teditBuilder.delete(new vscode.Range(start, end));\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Insert after indentation so we keep the original indentation\r\n\t\t\t\tconst insertPos = new vscode.Position(lineNum, line.firstNonWhitespaceCharacterIndex);\r\n\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.insert(insertPos, `${charcons.task.todo} `);\r\n\t\t\t\t});\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to mark as task: ${error.message}`);\r\n\t\t\t\tconsole.error('Mark as task error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\r\n\t\ttoggleTaskState: vscode.commands.registerCommand(`${EXTENSION_NAME}.toggleTaskState`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst doc = editor.document;\r\n\t\t\t\tconst lineNum = editor.selection.active.line;\r\n\t\t\t\tconst line = doc.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst leadingWhitespace = text.substring(0, line.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo)) {\r\n\t\t\t\t// Mark current task as done and add timestamp\r\n\t\t\t\tconst now = new Date();\r\n\t\t\t\tconst timestamp = ` @${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;\r\n\t\t\t\tconst taskContent = trimmed.slice(charcons.task.todo.length + 1);\r\n\t\t\t\tconst newTaskText = `${leadingWhitespace}${charcons.task.done} ${taskContent}${timestamp}`;\r\n\t\t\t\t\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.replace(line.range, newTaskText);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find and mark all subtasks as done\r\n\t\t\t\t\tconst currentIndentLevel = leadingWhitespace.length;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Look at all lines below the current task\r\n\t\t\t\t\tfor (let i = lineNum + 1; i < doc.lineCount; i++) {\r\n\t\t\t\t\t\tconst subtaskLine = doc.lineAt(i);\r\n\t\t\t\t\t\tconst subtaskText = subtaskLine.text;\r\n\t\t\t\t\t\tconst subtaskTrimmed = subtaskText.trim();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we reach an empty line or a line with same/less indentation that's not a task\r\n\t\t\t\t\t\tif (subtaskTrimmed === '') {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst subtaskIndentLevel = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex).length;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we encounter a line with same or less indentation\r\n\t\t\t\t\t\tif (subtaskIndentLevel <= currentIndentLevel) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// If it's a subtask (more indented and is a task), mark it as done with timestamp\r\n\t\t\t\t\t\tif (subtaskTrimmed.startsWith(charcons.task.todo)) {\r\n\t\t\t\t\t\t\tconst subtaskLeadingWhitespace = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\t\t\t\tconst subtaskContent = subtaskTrimmed.slice(charcons.task.todo.length + 1);\r\n\t\t\t\t\t\t\tconst newSubtaskText = `${subtaskLeadingWhitespace}${charcons.task.done} ${subtaskContent}${timestamp}`;\r\n\t\t\t\t\t\t\teditBuilder.replace(subtaskLine.range, newSubtaskText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else if (trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t// Mark current task as todo (undone) and remove timestamp\r\n\t\t\t\tlet taskContent = trimmed.slice(charcons.task.done.length + 1);\r\n\t\t\t\t// Remove timestamp if present (format: @YYYY-MM-DD HH:mm:ss)\r\n\t\t\t\ttaskContent = taskContent.replace(/ @\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/, '');\r\n\t\t\t\tconst newTaskText = `${leadingWhitespace}${charcons.task.todo} ${taskContent}`;\r\n\t\t\t\t\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\teditBuilder.replace(line.range, newTaskText);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find and mark all subtasks as undone (todo)\r\n\t\t\t\t\tconst currentIndentLevel = leadingWhitespace.length;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Look at all lines below the current task\r\n\t\t\t\t\tfor (let i = lineNum + 1; i < doc.lineCount; i++) {\r\n\t\t\t\t\t\tconst subtaskLine = doc.lineAt(i);\r\n\t\t\t\t\t\tconst subtaskText = subtaskLine.text;\r\n\t\t\t\t\t\tconst subtaskTrimmed = subtaskText.trim();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we reach an empty line or a line with same/less indentation that's not a task\r\n\t\t\t\t\t\tif (subtaskTrimmed === '') {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst subtaskIndentLevel = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex).length;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Stop if we encounter a line with same or less indentation\r\n\t\t\t\t\t\tif (subtaskIndentLevel <= currentIndentLevel) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// If it's a subtask (more indented and is a task), mark it as undone and remove timestamp\r\n\t\t\t\t\t\tif (subtaskTrimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t\t\tconst subtaskLeadingWhitespace = subtaskText.substring(0, subtaskLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\t\t\t\t\tlet subtaskContent = subtaskTrimmed.slice(charcons.task.done.length + 1);\r\n\t\t\t\t\t\t\t// Remove timestamp if present\r\n\t\t\t\t\t\t\tsubtaskContent = subtaskContent.replace(/ @\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/, '');\r\n\t\t\t\t\t\t\tconst newSubtaskText = `${subtaskLeadingWhitespace}${charcons.task.todo} ${subtaskContent}`;\r\n\t\t\t\t\t\t\teditBuilder.replace(subtaskLine.range, newSubtaskText);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to toggle task state: ${error.message}`);\r\n\t\t\t\tconsole.error('Toggle task state error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\r\n\t\tarchiveDone: vscode.commands.registerCommand(`${EXTENSION_NAME}.archiveDone`, archiveDone),\r\n\r\n\t\tindentTask: vscode.commands.registerCommand(`${EXTENSION_NAME}.indentTask`, function () {\r\n\t\t\ttry {\r\n\t\t\t\tconst editor = getDotodoEditorOrErrorMessage();\r\n\r\n\t\t\t\tif (!editor) {\r\n\t\t\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\t' });\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst selection = editor.selection;\r\n\t\t\tconst startLine = selection.start.line;\r\n\t\t\tconst endLine = selection.end.line;\r\n\r\n\t\t\t// Check if we have a multi-line selection\r\n\t\t\tif (startLine !== endLine) {\r\n\t\t\t\t// Multi-line selection: indent all task lines in the selection\r\n\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\tfor (let lineNum = startLine; lineNum <= endLine; lineNum++) {\r\n\t\t\t\t\t\tconst line = editor.document.lineAt(lineNum);\r\n\t\t\t\t\t\tconst text = line.text;\r\n\t\t\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\t\t\t// Only indent lines that are tasks\r\n\t\t\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t\t\teditBuilder.insert(new vscode.Position(lineNum, 0), '\\t');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}).then(() => {\r\n\t\t\t\t\t// Maintain the selection but adjust for the added tabs\r\n\t\t\t\t\tconst newStart = new vscode.Position(startLine, selection.start.character + 1);\r\n\t\t\t\t\tconst newEnd = new vscode.Position(endLine, selection.end.character + 1);\r\n\t\t\t\t\teditor.selection = new vscode.Selection(newStart, newEnd);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\t// Single line: existing behavior\r\n\t\t\t\tconst position = editor.selection.active;\r\n\t\t\t\tconst lineNum = position.line;\r\n\t\t\t\tconst line = editor.document.lineAt(lineNum);\r\n\t\t\t\tconst text = line.text;\r\n\t\t\t\tconst trimmed = text.trim();\r\n\r\n\t\t\t\t// Check if current line is a task\r\n\t\t\t\tif (trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) {\r\n\t\t\t\t\t// Add tab at the beginning of the line\r\n\t\t\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\t\t\teditBuilder.insert(new vscode.Position(lineNum, 0), '\\t');\r\n\t\t\t\t\t}).then(() => {\r\n\t\t\t\t\t\t// Maintain cursor position relative to the line content\r\n\t\t\t\t\t\tconst newPosition = new vscode.Position(lineNum, position.character + 1);\r\n\t\t\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Default tab behavior for non-task lines\r\n\t\t\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\t' });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvscode.window.showErrorMessage(`Failed to indent task: ${error.message}`);\r\n\t\t\t\tconsole.error('Indent task error:', error);\r\n\t\t\t}\r\n\t\t}),\r\n\t};\r\n\r\n\tregisterDecorations(context);\r\n\r\n\t// Track newly created empty tasks for double-enter cancellation\r\n\tlet lastCreatedTaskInfo = null;\r\n\r\n\t// Auto-create task on Enter key\r\n\tconst enterDisposable = vscode.commands.registerCommand(`${EXTENSION_NAME}.onEnter`, () => {\r\n\t\tconst editor = vscode.window.activeTextEditor;\r\n\t\tif (!editor || editor.document.languageId !== LANG_ID) {\r\n\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t}\r\n\r\n\t\tconst position = editor.selection.active;\r\n\t\tconst currentLine = editor.document.lineAt(position.line);\r\n\t\tconst currentText = currentLine.text;\r\n\t\tconst trimmed = currentText.trim();\r\n\r\n\t\t// Check for double-enter on empty task (cancel task creation)\r\n\t\tif (lastCreatedTaskInfo && \r\n\t\t\tlastCreatedTaskInfo.line === position.line && \r\n\t\t\tlastCreatedTaskInfo.text === currentText &&\r\n\t\t\ttrimmed === charcons.task.todo) {\r\n\t\t\t// Remove the task checkbox and space, keep only indentation\r\n\t\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.replace(currentLine.range, indentation);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Insert newline after removing checkbox\r\n\t\t\t\tvscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t\t});\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Check if current line is a task AND cursor is at the end of the line\r\n\t\tif ((trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done)) && \r\n\t\t\tposition.character === currentText.length) {\r\n\t\t\t// Get indentation of current line\r\n\t\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\t\t\tconst newTaskLine = `${indentation}${charcons.task.todo} `;\r\n\t\t\t\r\n\t\t\t// Insert new line with new task at the end of current line\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.insert(new vscode.Position(position.line, currentText.length), '\\n' + newTaskLine);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Position cursor at end of new task line\r\n\t\t\t\tconst newPosition = new vscode.Position(position.line + 1, newTaskLine.length);\r\n\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t\t\r\n\t\t\t\t// Track this new task for potential double-enter cancellation\r\n\t\t\t\tlastCreatedTaskInfo = {\r\n\t\t\t\t\tline: position.line + 1,\r\n\t\t\t\t\ttext: newTaskLine\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// Default behavior for non-task lines or when cursor is not at end\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t\treturn vscode.commands.executeCommand('default:type', { text: '\\n' });\r\n\t\t}\r\n\t});\r\n\r\n\t// Handle BACKSPACE key to cancel task creation\r\n\tconst backspaceDisposable = vscode.commands.registerCommand(`${EXTENSION_NAME}.onBackspace`, () => {\r\n\t\tconst editor = vscode.window.activeTextEditor;\r\n\t\tif (!editor || editor.document.languageId !== LANG_ID) {\r\n\t\t\treturn vscode.commands.executeCommand('deleteLeft');\r\n\t\t}\r\n\r\n\t\tconst position = editor.selection.active;\r\n\t\tconst currentLine = editor.document.lineAt(position.line);\r\n\t\tconst currentText = currentLine.text;\r\n\t\tconst trimmed = currentText.trim();\r\n\t\tconst indentation = currentText.substring(0, currentLine.firstNonWhitespaceCharacterIndex);\r\n\r\n\t\t// Check if cursor is right after the space following the checkbox (at the end of \"☐ \")\r\n\t\tif (lastCreatedTaskInfo && \r\n\t\t\tlastCreatedTaskInfo.line === position.line && \r\n\t\t\ttrimmed === charcons.task.todo &&\r\n\t\t\tposition.character === indentation.length + charcons.task.todo.length + 1) {\r\n\t\t\t// Remove checkbox and space, keep indentation\r\n\t\t\teditor.edit(editBuilder => {\r\n\t\t\t\teditBuilder.replace(currentLine.range, indentation);\r\n\t\t\t}).then(() => {\r\n\t\t\t\t// Move cursor to end of indentation\r\n\t\t\t\tconst newPosition = new vscode.Position(position.line, indentation.length);\r\n\t\t\t\teditor.selection = new vscode.Selection(newPosition, newPosition);\r\n\t\t\t});\r\n\t\t\tlastCreatedTaskInfo = null;\r\n\t\t} else {\r\n\t\t\t// Default BACKSPACE behavior\r\n\t\t\treturn vscode.commands.executeCommand('deleteLeft');\r\n\t\t}\r\n\t});\r\n\r\n\tcontext.subscriptions.push(enterDisposable, backspaceDisposable);\r\n\r\n\t// Without pushing to context.subscriptions, cleanup would not happen \r\n\t// automatically, which can cause issues especially if the extension \r\n\t// is enabled/disabled multiple times during a session.\r\n\tcontext.subscriptions.push(...Object.values(subscriptions));\r\n\t// context.subscriptions.push(commands.markAsTask);\r\n}\r\n\r\n// This method is called when your extension is deactivated\r\nfunction deactivate() {}\r\n\r\nfunction archiveDone() {\r\n    try {\r\n        const editor = getDotodoEditorOrErrorMessage();\r\n        if (!editor) return;\r\n\r\n        const doc = editor.document;\r\n    const allLines = [];\r\n    const doneTasksWithContent = [];\r\n    const linesToSkip = new Set();\r\n\r\n    // Helper function to check if line is a task\r\n    function isTaskLine(trimmed) {\r\n        return trimmed.startsWith(charcons.task.todo) || trimmed.startsWith(charcons.task.done);\r\n    }\r\n\r\n    // Helper function to check if line is a section\r\n    function isSectionLine(trimmed) {\r\n        return trimmed.endsWith(':') || (trimmed.includes(':') && trimmed.includes('(') && trimmed.endsWith(')'));\r\n    }\r\n\r\n    // Helper to get content lines for a task\r\n    function getTaskContentLines(taskLineNum) {\r\n        const contentLines = [];\r\n        const taskLine = doc.lineAt(taskLineNum);\r\n        const taskIndent = taskLine.text.substring(0, taskLine.firstNonWhitespaceCharacterIndex).length;\r\n\r\n        for (let i = taskLineNum + 1; i < doc.lineCount; i++) {\r\n            const line = doc.lineAt(i);\r\n            const trimmed = line.text.trim();\r\n            const lineIndent = line.text.substring(0, line.firstNonWhitespaceCharacterIndex).length;\r\n\r\n            if (trimmed === '') {\r\n                contentLines.push(i);\r\n                continue;\r\n            }\r\n\r\n            if (isTaskLine(trimmed) && lineIndent <= taskIndent) {\r\n                break;\r\n            }\r\n\r\n            if (isSectionLine(trimmed)) {\r\n                break;\r\n            }\r\n\r\n            if (isTaskLine(trimmed) && lineIndent > taskIndent) {\r\n                break;\r\n            }\r\n\r\n            contentLines.push(i);\r\n        }\r\n\r\n        return contentLines;\r\n    }\r\n\r\n    // First pass: collect done tasks with their content\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n        if (linesToSkip.has(i)) continue;\r\n\r\n        const line = doc.lineAt(i);\r\n        const trimmed = line.text.trim();\r\n        \r\n        if (trimmed.startsWith(charcons.task.done)) {\r\n            // Add the task line\r\n            doneTasksWithContent.push(line.text);\r\n            linesToSkip.add(i);\r\n\r\n            // Get and add content lines\r\n            const contentLines = getTaskContentLines(i);\r\n            for (const contentLineNum of contentLines) {\r\n                doneTasksWithContent.push(doc.lineAt(contentLineNum).text);\r\n                linesToSkip.add(contentLineNum);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (doneTasksWithContent.length === 0) {\r\n        vscode.window.showInformationMessage('No done tasks to archive');\r\n        return;\r\n    }\r\n\r\n    // Second pass: collect remaining lines\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n        if (!linesToSkip.has(i)) {\r\n            allLines.push(doc.lineAt(i).text);\r\n        }\r\n    }\r\n\r\n    // Check if Archived exists\r\n    let hasArchived = false;\r\n    for (let line of allLines) {\r\n        if (line.trim().startsWith('Archived:')) {\r\n            hasArchived = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!hasArchived) {\r\n        allLines.push('', 'Archived:');\r\n    }\r\n\r\n    // Add done tasks with their content\r\n    allLines.push(...doneTasksWithContent);\r\n\r\n    // Replace entire document\r\n    const newText = allLines.join('\\n');\r\n    editor.edit(editBuilder => {\r\n        editBuilder.replace(new vscode.Range(0, 0, doc.lineCount, 0), newText);\r\n    });\r\n    } catch (error) {\r\n        vscode.window.showErrorMessage(`Failed to archive done tasks: ${error.message}`);\r\n        console.error('Archive done error:', error);\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n\tactivate,\r\n\tdeactivate\r\n}\r\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(12);\n"],"names":["vscode","EXTENSION_NAME","LANG_ID","charcons","getDotodoEditorOrErrorMessage","activeEditor","window","activeTextEditor","document","languageId","showErrorMessage","archiveDone","editor","doc","allLines","doneTasksWithContent","linesToSkip","Set","isTaskLine","trimmed","startsWith","isSectionLine","endsWith","includes","getTaskContentLines","taskLineNum","contentLines","taskLine","lineAt","taskIndent","text","substring","firstNonWhitespaceCharacterIndex","length","i","lineCount","line","trim","lineIndent","push","has","add","contentLineNum","showInformationMessage","hasArchived","newText","join","edit","editBuilder","replace","Range","error","message","console","module","exports","activate","context","subscriptions","markAsTask","commands","registerCommand","lineNum","selection","active","insertCol","start","Position","end","delete","insertPos","insert","toggleTaskState","leadingWhitespace","now","Date","timestamp","getFullYear","String","getMonth","padStart","getDate","getHours","getMinutes","getSeconds","taskContent","slice","newTaskText","range","currentIndentLevel","subtaskLine","subtaskText","subtaskTrimmed","subtaskLeadingWhitespace","subtaskContent","newSubtaskText","indentTask","executeCommand","startLine","endLine","then","newStart","character","newEnd","Selection","position","newPosition","taskContentCache","Map","documentVersion","todoDecoration","createTextEditorDecorationType","color","ThemeColor","doneDecoration","textDecoration","timestampDecoration","after","fontStyle","margin","sectionDecoration","fontWeight","counterDecoration","updateDecorations","version","clear","todoRanges","doneRanges","sectionRanges","counterRanges","checkboxStart","checkboxEnd","getNonWhitespaceRanges","contentLine","sectionName","extractSectionName","doneCount","allCount","countTasksInSection","counterText","renderOptions","contentText","setDecorations","indexOf","cacheKey","uri","toString","get","set","ranges","sectionLine","todoCount","nextSectionLine","onDidChangeActiveTextEditor","workspace","onDidChangeTextDocument","event","registerDecorations","lastCreatedTaskInfo","enterDisposable","currentLine","currentText","indentation","newTaskLine","backspaceDisposable","Object","values","deactivate","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"ignoreList":[],"sourceRoot":""}